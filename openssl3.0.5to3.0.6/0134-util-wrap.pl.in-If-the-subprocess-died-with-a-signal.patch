From 41f238d830e510f6d4bde63dd822e3041f14fc15 Mon Sep 17 00:00:00 2001
From: Richard Levitte <levitte@openssl.org>
Date: Mon, 22 Aug 2022 18:40:54 +0200
Subject: [PATCH 134/209] util/wrap.pl.in: If the subprocess died with a
 signal, let's re-signal it

A simple 'kill' of the same signal on our own process should do it.
This will allow the shell that this is running under to catch it
properly, and output something if it usually does that.

Fixes #19041

Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
Reviewed-by: Matt Caswell <matt@openssl.org>
Reviewed-by: Paul Dale <pauli@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/19042)

(cherry picked from commit bf16ee4f95c31a66e76056c691f25a0d2b4a39c4)
---
 util/wrap.pl.in | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/util/wrap.pl.in b/util/wrap.pl.in
index b13c34d851..de4692f319 100644
--- a/util/wrap.pl.in
+++ b/util/wrap.pl.in
@@ -68,7 +68,10 @@ my $waitcode = system @cmd;
 die "wrap.pl: Failed to execute '", join(' ', @cmd), "': $!\n"
     if $waitcode == -1;
 
-# When the subprocess aborted on a signal, mimic what Unix shells do, by
+# When the subprocess aborted on a signal, we simply raise the same signal.
+kill ($? & 255) => $$ if ($? & 255) != 0;
+
+# If that didn't stop this script, mimic what Unix shells do, by
 # converting the signal code to an exit code by setting the high bit.
 # This only happens on Unix flavored operating systems, the others don't
 # have this sort of signaling to date, and simply leave the low byte zero.
-- 
2.34.1

