From 54e38d82edef757c098341f0ef0f9e8fed6f6945 Mon Sep 17 00:00:00 2001
From: "Dr. David von Oheimb" <David.von.Oheimb@siemens.com>
Date: Tue, 12 Jul 2022 23:55:28 +0200
Subject: [PATCH 067/209] check-format.pl: fix detection of missing/extra blank
 lines in local decls

Reviewed-by: Richard Levitte <levitte@openssl.org>
Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Hugo Landau <hlandau@openssl.org>
(cherry picked from commit 23757b61d49ac3e46440dc34e56b83201106e440)
---
 util/check-format-test-negatives.c | 47 ++++++++++++++++++++++++++++++
 util/check-format-test-positives.c |  4 +--
 util/check-format.pl               | 28 +++++++++---------
 3 files changed, 64 insertions(+), 15 deletions(-)

diff --git a/util/check-format-test-negatives.c b/util/check-format-test-negatives.c
index 58a1f59e6c..9edd0b20c2 100644
--- a/util/check-format-test-negatives.c
+++ b/util/check-format-test-negatives.c
@@ -48,6 +48,10 @@ int f(void) /*
     const int con;
     volatile int vola;
     register int reg;
+    OSSL_x y, *p = params;
+    int params[];
+    OSSL_PARAM * (* params []) [MAX + 1];
+    XY *(* fn)(int a, char b);
     /*
      * multi-line comment should not disturb detection of local decls
      */
@@ -56,6 +60,48 @@ int f(void) /*
     unsigned k;
 
     /* intra-line comment should not disturb detection of end of local decls */
+
+    {
+        int x; /* just decls in block */
+    }
+    if (p != (unsigned char *)
+        &(ctx->tmp[0])) {
+        i -= (p - (unsigned char *) /* do not confuse with var decl */
+              &(ctx->tmp[0]));
+    }
+    {
+        ctx->buf_off = 0; /* do not confuse with var decl */
+        return 0;
+    }
+    {
+        ctx->buf_len = EVP_EncodeBlock((unsigned char *)ctx->buf,
+                                       (unsigned char *)ctx->tmp, /* no decl */
+                                       ctx->tmp_len);
+    }
+    {
+        EVP_EncodeFinal(ctx->base64,
+                        (unsigned char *)ctx->buf, &(ctx->len)); /* no decl */
+        /* push out the bytes */
+        goto again;
+    }
+    {
+        f(1, (unsigned long)2); /* no decl */
+        x;
+    }
+    {
+        char *pass_str = get_passwd(opt_srv_secret, "x");
+
+        if (pass_str != NULL) {
+            cleanse(opt_srv_secret);
+            res = OSSL_CMP_CTX_set1_secretValue(ctx, (unsigned char *)pass_str,
+                                                strlen(pass_str));
+            clear_free(pass_str);
+        }
+    }
+}
+
+int g(void)
+{
     if (ctx == NULL) {    /* non-leading end-of-line comment */
         if (/* comment after '(' */ pem_name != NULL /* comment before ')' */)
             /* entire-line comment indent usually like for the following line */
@@ -222,6 +268,7 @@ x;
 typedef OSSL_CMP_MSG *(*cmp_srv_process_cb_t)
     (OSSL_CMP_SRV_CTX *ctx, OSSL_CMP_MSG *msg)
     xx;
+
 int f()
 {
     c;
diff --git a/util/check-format-test-positives.c b/util/check-format-test-positives.c
index df19288480..6d2b1ce5a2 100644
--- a/util/check-format-test-positives.c
+++ b/util/check-format-test-positives.c
@@ -72,8 +72,8 @@ void main(int n) {  /*@ opening brace at end of function definition header */
 int f (int a,       /*@ space after fn before '(', reported unless sloppy-spc */
       int b,        /*@ hanging expr indent off by -1 */
        long I)      /*@ single-letter name 'I' */
-{ int               /*@ code after '{' opening a block */
-    xx = 1) +       /*@ unexpected closing parenthesis */
+{ int x;            /*@ code after '{' opening a block */
+    int xx = 1) +   /*@ unexpected closing parenthesis */
         0L <        /*@ constant on LHS of comparison operator */
         a] -        /*@ unexpected closing bracket */
         3: *        /*@ unexpected ':' (without preceding '?') within expr */
diff --git a/util/check-format.pl b/util/check-format.pl
index 9fcebb4382..be84d733ff 100755
--- a/util/check-format.pl
+++ b/util/check-format.pl
@@ -169,7 +169,7 @@ my @nested_symbols;        # stack of hanging symbols '(', '{', '[', or '?', in
 my @nested_conds_indents;  # stack of hanging indents due to conditionals ('?' ... ':')
 my $expr_indent;           # resulting hanging indent within (multi-line) expressions including type exprs, else 0
 my $hanging_symbol;        # character ('(', '{', '[', not: '?') responsible for $expr_indent, if $expr_indent != 0
-my $in_block_decls;        # number of local declaration lines after block opening before normal statements
+my $in_block_decls;        # number of local declaration lines after block opening before normal statements, or -1 if no block opening
 my $in_expr;               # in expression after if/while/for/switch/return/enum/LHS of assignment
 my $in_paren_expr;         # in parenthesized if/while/for condition and switch expression, if $expr_indent != 0
 my $in_typedecl;           # nesting level of typedef/struct/union/enum
@@ -845,19 +845,21 @@ while (<>) { # loop over all lines of all input files
     # check for blank lines within/after local decls @@@@@@@@@@@@@@@@@@@@@@@@@@@
 
     if ($in_block_decls >= 0 &&
-        $in_comment == 0 && !m/^\s*\*?@/ && # not multi-line or intra-line comment
-        !$in_expr && $in_typedecl == 0) {
-        my $blank_line_before = $line > 1 && $code_contents_before =~ m/^\s*(\\\s*)?$/;
-        # essentially blank line: just whitespace (and maybe a trailing '\')
-        if (m/^\s*(void|char|signed|unsigned|int|short|long|float|double|typedef|enum|struct|union|auto|extern|static|const|volatile|register)(\W|$)/ ||
-            (m/[\w)]\s+[*]*\w/ &&
-             !m/^\s*(\}|sizeof|if|else|while|do|for|switch|case|default|break|continue|goto|return)(\W|$)/)) {
-            report_flexibly($line - 1, "blank line within local decls, before", $contents) if $blank_line_before;
+        $in_comment == 0 && !m/^\s*\*?@/ && # not in multi-line comment nor an intra-line comment
+        !$in_expr && $expr_indent == 0 && $in_typedecl == 0) {
+        my $blank_line_before = $line > 1
+            && $code_contents_before =~ m/^\s*(\\\s*)?$/; # essentially blank line: just whitespace (and maybe a trailing '\')
+        if (m/^[\s(]*(char|signed|unsigned|int|short|long|float|double|enum|struct|union|auto|extern|static|const|volatile|register)(\W|$)/ # clear start of local decl
+            || (m/^(\s*(\w+|\[\]|[\*()]))+?\s+[\*\(]*\w+(\s*(\)|\[[^\]]*\]))*\s*[;,=]/ # weak check for decl involving user-defined type
+                && !m/^\s*(\}|sizeof|if|else|while|do|for|switch|case|default|break|continue|goto|return)(\W|$)/)) {
             $in_block_decls++;
-        } elsif ($in_block_decls > 0) {
+            report_flexibly($line - 1, "blank line within local decls, before", $contents) if $blank_line_before;
+        } else {
             report_flexibly($line, "missing blank line after local decls", "\n$contents_before$contents")
-                unless $blank_line_before;
-            $in_block_decls = -1;
+                if $in_block_decls > 0 && !$blank_line_before;
+            $in_block_decls = -1 unless
+                m/^\s*(\\\s*)?$/ # essentially blank line: just whitespace (and maybe a trailing '\')
+            || $in_comment != 0 || m/^\s*\*?@/; # in multi-line comment or an intra-line comment
         }
     }
 
@@ -1114,7 +1116,7 @@ while (<>) { # loop over all lines of all input files
   LINE_FINISHED:
     $code_contents_before = $contents if
         !m/^\s*#(\s*)(\w+)/ && # not single-line directive
-        $in_comment == 0 && !m/^\s*\*?@/; # not multi-line or intra-line comment
+        $in_comment == 0 && !m/^\s*\*?@/; # not in multi-line comment nor an intra-line comment
 
     # on end of multi-line preprocessor directive, adapt indent
     if ($in_directive > 0 &&
-- 
2.34.1

